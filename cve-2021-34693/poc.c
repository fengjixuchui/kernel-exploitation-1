#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <linux/can.h>
#include <linux/can/bcm.h>

void
rxsetup_sock(int sock)
{
        struct iovec iov;
        struct msghdr m;
        struct bcm_msg_head b;
	struct {
		struct bcm_msg_head b;
		struct canfd_frame f;
	} msg;

	memset(&msg, 0, sizeof(msg));

        iov.iov_base = &msg;
        iov.iov_len = sizeof(msg);

        msg.b.opcode = RX_SETUP;
        msg.b.flags = CAN_FD_FRAME | SETTIMER | STARTTIMER;
        msg.b.count = 0;
        msg.b.ival1.tv_sec = msg.b.ival2.tv_sec = 0;
        msg.b.ival1.tv_usec = msg.b.ival2.tv_usec = 1;
        msg.b.can_id = 0;
        msg.b.nframes = 1;

	m.msg_name = NULL;
	m.msg_namelen = 0;
        m.msg_iov = &iov;
        m.msg_iovlen = 1;
	m.msg_control = 0;
	m.msg_controllen = 0;
	m.msg_flags = 0;

        sendmsg(sock, &m, 0);
}

int
main(void)
{
	int i;
	int sock;
	struct sockaddr_can sa;
	struct {
		struct bcm_msg_head b;
		struct canfd_frame f[1];
	} msg;
	char buf[sizeof(msg)];

	sock = socket(AF_CAN, SOCK_DGRAM, CAN_BCM);

	sa.can_family = AF_CAN;
	sa.can_ifindex = 0;
	sa.can_addr.tp.rx_id = 0;
	sa.can_addr.tp.tx_id = 0;

	connect(sock, (struct sockaddr *)&sa, sizeof(sa));

	rxsetup_sock(sock);

	memset(&sa, 0, sizeof(sa));
	sa.can_family = AF_CAN;
	sa.can_ifindex = 0;
	socklen_t len = 0;

	memset(&msg, 0, sizeof(msg));

	recvfrom(sock, &msg, sizeof(msg), 0,
			(struct sockaddr *)&sa, &len);

	memcpy(buf, &msg, sizeof(buf));

	for (i = 0; i < sizeof(buf); i++)
		printf("%x ", (unsigned char)buf[i]);
	printf("\n");

	return 0;
}
